import pytest
from app import create_app, db
from app.models.models import User
from config import config_by_name


@pytest.fixture
def app():
    app = create_app()

    config_name = 'testing'
    app.config.from_object(config_by_name[config_name])
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()


@pytest.fixture
def client(app):
    with app.test_client() as client:
        with app.app_context():
            yield client


@pytest.fixture
def sample_user():
    user = User(username='testuser2', email='test2@example.com')
    user.set_password('testpassword2')
    return user


def test_sql_injection_protection(client, sample_user):
    """
    Test to ensure that the application is protected against SQL injection.
    This test will attempt an SQL injection via the username field.
    The application should not authenticate or process this input.
    """
    db.session.add(sample_user)
    db.session.commit()
    malicious_input = "'delete * from user"
    response = client.post('/users/create', data={
        'username': malicious_input,
        'password': malicious_input
    })

    # Optionally, check if the malicious input was not created as a new user in the database.
    user_exists = User.query.filter_by(username=malicious_input).first()
    assert user_exists is None


def test_sql_injection_protection2(client, sample_user):
    """
    Test to ensure that the application is protected against SQL injection.
    This test will attempt an SQL injection via the username field.
    The application should not authenticate or process this input.
    """
    db.session.add(sample_user)
    db.session.commit()
    malicious_input = "'; select true; --"
    response = client.post('/users/create', data={
        'username': malicious_input,
        'password': malicious_input
    })

    # Optionally, check if the malicious input was not created as a new user in the database.
    user_exists = User.query.filter_by(username=malicious_input).first()
    assert user_exists is None

def test_sql_injection_protection3(client, sample_user):
    """
    Test to ensure that the application is protected against SQL injection.
    This test will attempt an SQL injection via the username field.
    The application should not process this input in a way that affects the database.
    """
    db.session.add(sample_user)
    db.session.commit()

    # Get initial count of users
    initial_user_count = User.query.count()

    malicious_input = "' OR '1'='1"
    response = client.post('/users/create', data={
        'username': malicious_input,
        'password': malicious_input
    })

    # Get count of users after the malicious request
    new_user_count = User.query.count()

    # Assert that the user count has not changed
    assert new_user_count == initial_user_count